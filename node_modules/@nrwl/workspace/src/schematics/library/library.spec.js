"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const testing_1 = require("@nrwl/workspace/testing");
const workspace_1 = require("@nrwl/workspace");
const testing_2 = require("../../utils/testing");
describe('lib', () => {
    let appTree;
    beforeEach(() => {
        appTree = schematics_1.Tree.empty();
        appTree = testing_1.createEmptyWorkspace(appTree);
    });
    describe('not nested', () => {
        it('should update workspace.json', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield testing_2.runSchematic('lib', { name: 'myLib' }, appTree);
            const workspaceJson = workspace_1.readJsonInTree(tree, '/workspace.json');
            expect(workspaceJson.projects['my-lib'].root).toEqual('libs/my-lib');
            expect(workspaceJson.projects['my-lib'].architect.build).toBeUndefined();
            expect(workspaceJson.projects['my-lib'].architect.lint).toEqual({
                builder: '@angular-devkit/build-angular:tslint',
                options: {
                    exclude: ['**/node_modules/**', '!libs/my-lib/**'],
                    tsConfig: [
                        'libs/my-lib/tsconfig.lib.json',
                        'libs/my-lib/tsconfig.spec.json',
                    ],
                },
            });
        }));
        it('should update nx.json', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield testing_2.runSchematic('lib', { name: 'myLib', tags: 'one,two' }, appTree);
            const nxJson = workspace_1.readJsonInTree(tree, '/nx.json');
            expect(nxJson.projects).toEqual({
                'my-lib': {
                    tags: ['one', 'two'],
                },
            });
        }));
        it('should update root tsconfig.json', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield testing_2.runSchematic('lib', { name: 'myLib' }, appTree);
            const tsconfigJson = workspace_1.readJsonInTree(tree, '/tsconfig.json');
            expect(tsconfigJson.compilerOptions.paths['@proj/my-lib']).toEqual([
                'libs/my-lib/src/index.ts',
            ]);
        }));
        it('should create a local tsconfig.json', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield testing_2.runSchematic('lib', { name: 'myLib' }, appTree);
            const tsconfigJson = workspace_1.readJsonInTree(tree, 'libs/my-lib/tsconfig.json');
            expect(tsconfigJson).toEqual({
                extends: '../../tsconfig.json',
                compilerOptions: {
                    types: ['node', 'jest'],
                },
                include: ['**/*.ts'],
            });
        }));
        it('should extend the local tsconfig.json with tsconfig.spec.json', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield testing_2.runSchematic('lib', { name: 'myLib' }, appTree);
            const tsconfigJson = workspace_1.readJsonInTree(tree, 'libs/my-lib/tsconfig.spec.json');
            expect(tsconfigJson.extends).toEqual('./tsconfig.json');
        }));
        it('should extend the local tsconfig.json with tsconfig.lib.json', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield testing_2.runSchematic('lib', { name: 'myLib' }, appTree);
            const tsconfigJson = workspace_1.readJsonInTree(tree, 'libs/my-lib/tsconfig.lib.json');
            expect(tsconfigJson.extends).toEqual('./tsconfig.json');
        }));
        it('should generate files', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield testing_2.runSchematic('lib', { name: 'myLib' }, appTree);
            expect(tree.exists(`libs/my-lib/jest.config.js`)).toBeTruthy();
            expect(tree.exists('libs/my-lib/src/index.ts')).toBeTruthy();
            expect(tree.exists('libs/my-lib/src/lib/my-lib.ts')).toBeTruthy();
        }));
    });
    describe('nested', () => {
        it('should update nx.json', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield testing_2.runSchematic('lib', {
                name: 'myLib',
                directory: 'myDir',
                tags: 'one',
            }, appTree);
            const nxJson = workspace_1.readJsonInTree(tree, '/nx.json');
            expect(nxJson.projects).toEqual({
                'my-dir-my-lib': {
                    tags: ['one'],
                },
            });
            const tree2 = yield testing_2.runSchematic('lib', {
                name: 'myLib2',
                directory: 'myDir',
                tags: 'one,two',
                simpleModuleName: true,
            }, tree);
            const nxJson2 = workspace_1.readJsonInTree(tree2, '/nx.json');
            expect(nxJson2.projects).toEqual({
                'my-dir-my-lib': {
                    tags: ['one'],
                },
                'my-dir-my-lib2': {
                    tags: ['one', 'two'],
                },
            });
        }));
        it('should generate files', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield testing_2.runSchematic('lib', { name: 'myLib', directory: 'myDir' }, appTree);
            expect(tree.exists(`libs/my-dir/my-lib/jest.config.js`)).toBeTruthy();
            expect(tree.exists('libs/my-dir/my-lib/src/index.ts')).toBeTruthy();
            expect(tree.exists('libs/my-dir/my-lib/src/lib/my-dir-my-lib.ts')).toBeTruthy();
            expect(tree.exists('libs/my-dir/my-lib/src/index.ts')).toBeTruthy();
            expect(tree.exists(`libs/my-dir/my-lib/tslint.json`)).toBeTruthy();
        }));
        it('should update workspace.json', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield testing_2.runSchematic('lib', { name: 'myLib', directory: 'myDir' }, appTree);
            const workspaceJson = workspace_1.readJsonInTree(tree, '/workspace.json');
            expect(workspaceJson.projects['my-dir-my-lib'].root).toEqual('libs/my-dir/my-lib');
            expect(workspaceJson.projects['my-dir-my-lib'].architect.lint).toEqual({
                builder: '@angular-devkit/build-angular:tslint',
                options: {
                    exclude: ['**/node_modules/**', '!libs/my-dir/my-lib/**'],
                    tsConfig: [
                        'libs/my-dir/my-lib/tsconfig.lib.json',
                        'libs/my-dir/my-lib/tsconfig.spec.json',
                    ],
                },
            });
        }));
        it('should update tsconfig.json', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield testing_2.runSchematic('lib', { name: 'myLib', directory: 'myDir' }, appTree);
            const tsconfigJson = workspace_1.readJsonInTree(tree, '/tsconfig.json');
            expect(tsconfigJson.compilerOptions.paths['@proj/my-dir/my-lib']).toEqual(['libs/my-dir/my-lib/src/index.ts']);
            expect(tsconfigJson.compilerOptions.paths['my-dir-my-lib/*']).toBeUndefined();
        }));
        it('should create a local tsconfig.json', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield testing_2.runSchematic('lib', { name: 'myLib', directory: 'myDir' }, appTree);
            const tsconfigJson = workspace_1.readJsonInTree(tree, 'libs/my-dir/my-lib/tsconfig.json');
            expect(tsconfigJson).toEqual({
                extends: '../../../tsconfig.json',
                compilerOptions: {
                    types: ['node', 'jest'],
                },
                include: ['**/*.ts'],
            });
        }));
        it('should create a local tslint.json', () => __awaiter(void 0, void 0, void 0, function* () {
            const tree = yield testing_2.runSchematic('lib', { name: 'myLib', directory: 'myDir' }, appTree);
            const tslintJson = workspace_1.readJsonInTree(tree, 'libs/my-dir/my-lib/tslint.json');
            expect(tslintJson).toEqual({
                extends: '../../../tslint.json',
                rules: {},
                linterOptions: {
                    exclude: ['!**/*'],
                },
            });
        }));
    });
    describe('--unit-test-runner none', () => {
        it('should not generate test configuration', () => __awaiter(void 0, void 0, void 0, function* () {
            const resultTree = yield testing_2.runSchematic('lib', { name: 'myLib', unitTestRunner: 'none' }, appTree);
            expect(resultTree.exists('libs/my-lib/tsconfig.spec.json')).toBeFalsy();
            expect(resultTree.exists('libs/my-lib/jest.config.js')).toBeFalsy();
            const workspaceJson = workspace_1.readJsonInTree(resultTree, 'workspace.json');
            expect(workspaceJson.projects['my-lib'].architect.test).toBeUndefined();
            expect(workspaceJson.projects['my-lib'].architect.lint.options.tsConfig).toEqual(['libs/my-lib/tsconfig.lib.json']);
        }));
    });
});
