"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const tmp_1 = require("tmp");
const fs_1 = require("fs");
const testing_1 = require("@angular-devkit/architect/testing");
const architect_1 = require("@angular-devkit/architect");
const path_1 = require("path");
const file_utils_1 = require("@nrwl/workspace/src/core/file-utils");
function readFile(f) {
    return fs_1.readFileSync(f).toString().replace(/\s/g, '');
}
describe('Command Runner Builder', () => {
    let architect;
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        const registry = new core_1.schema.CoreSchemaRegistry();
        registry.addPostTransform(core_1.schema.transforms.addUndefinedDefaults);
        const testArchitectHost = new testing_1.TestingArchitectHost('/root', '/root');
        architect = new architect_1.Architect(testArchitectHost, registry);
        yield testArchitectHost.addBuilderFromPackage(path_1.join(__dirname, '../../..'));
    }));
    it('should error when no commands are given', () => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {});
            yield run.output.toPromise();
            fail('should throw');
        }
        catch (e) {
            expect(e.message).toContain(`Schema validation failed`);
            expect(e.message).toContain(`path "" should have required property 'commands'`);
        }
    }));
    it('should error when no command is given', () => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
                commands: [{}],
            });
            yield run.result;
            fail('should throw');
        }
        catch (e) {
            expect(e.message).toContain(`Schema validation failed`);
            expect(e.message).toContain(`path ".commands[0]" should have required property 'command'`);
        }
    }));
    describe('no readyCondition', () => {
        it('should run commands serially', () => __awaiter(void 0, void 0, void 0, function* () {
            const f = tmp_1.fileSync().name;
            const exec = spyOn(require('child_process'), 'exec').and.callThrough();
            const scheduleRun = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
                commands: [
                    {
                        command: `sleep 0.2 && echo 1 >> ${f}`,
                    },
                    {
                        command: `sleep 0.1 && echo 2 >> ${f}`,
                    },
                ],
                parallel: false,
            });
            //wait a tick for the serial runner to schedule the first task
            yield Promise.resolve();
            const processesCreated = exec.calls.count();
            expect(processesCreated).toBe(1);
            const run = yield scheduleRun;
            const result = yield run.result;
            expect(result).toEqual(jasmine.objectContaining({ success: true }));
            expect(readFile(f)).toEqual('12');
        }));
        it('should run commands in parallel', () => __awaiter(void 0, void 0, void 0, function* () {
            const f = tmp_1.fileSync().name;
            const exec = spyOn(require('child_process'), 'exec').and.callThrough();
            const scheduleRun = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
                commands: [
                    {
                        command: `echo 1 >> ${f}`,
                    },
                    {
                        command: `echo 2 >> ${f}`,
                    },
                ],
                parallel: true,
            });
            const processesCreated = exec.calls.count();
            expect(processesCreated).toBe(2);
            const run = yield scheduleRun;
            const result = yield run.result;
            expect(result).toEqual(jasmine.objectContaining({ success: true }));
            const contents = readFile(f);
            expect(contents).toContain(1);
            expect(contents).toContain(2);
        }));
    });
    describe('readyWhen', () => {
        it('should error when parallel = false', () => __awaiter(void 0, void 0, void 0, function* () {
            try {
                const run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
                    commands: [{ command: 'some command' }],
                    parallel: false,
                    readyWhen: 'READY',
                });
                yield run.result;
                fail('should throw');
            }
            catch (e) {
                expect(e).toEqual(`ERROR: Bad builder config for @nrwl/run-command - "readyWhen" can only be used when parallel=true`);
            }
        }));
        it('should return success true when the string specified is ready condition is found', (done) => __awaiter(void 0, void 0, void 0, function* () {
            const f = tmp_1.fileSync().name;
            const run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
                commands: [
                    {
                        command: `echo READY && sleep 0.1 && echo 1 >> ${f}`,
                    },
                ],
                parallel: true,
                readyWhen: 'READY',
            });
            let successEmitted = false;
            run.output.subscribe((result) => {
                successEmitted = true;
                expect(result.success).toEqual(true);
                expect(readFile(f)).toEqual('');
            });
            setTimeout(() => {
                expect(successEmitted).toEqual(true);
                expect(readFile(f)).toEqual('1');
                done();
            }, 150);
        }));
    });
    it('should stop execution when a command fails', () => __awaiter(void 0, void 0, void 0, function* () {
        const f = tmp_1.fileSync().name;
        const run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
            commands: [
                {
                    command: `echo 1 >> ${f} && exit 1`,
                },
                {
                    command: `echo 2 >> ${f}`,
                },
            ],
            parallel: false,
        });
        const result = yield run.result;
        expect(result).toEqual(jasmine.objectContaining({ success: false }));
        expect(readFile(f)).toEqual('1');
    }));
    it('should throw when invalid args', () => __awaiter(void 0, void 0, void 0, function* () {
        const f = tmp_1.fileSync().name;
        try {
            const run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
                commands: [
                    {
                        command: `echo {args.key} >> ${f}`,
                    },
                ],
                args: 'key=value',
            });
            yield run.result;
        }
        catch (e) {
            expect(e.message).toEqual('Invalid args: key=value');
        }
    }));
    it('should enable parameter substitution', () => __awaiter(void 0, void 0, void 0, function* () {
        const f = tmp_1.fileSync().name;
        const run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
            commands: [
                {
                    command: `echo {args.key} >> ${f}`,
                },
            ],
            args: '--key=value',
        });
        const result = yield run.result;
        expect(result).toEqual(jasmine.objectContaining({ success: true }));
        expect(readFile(f)).toEqual('value');
    }));
    describe('--color', () => {
        it('should set FORCE_COLOR=true', () => __awaiter(void 0, void 0, void 0, function* () {
            const exec = spyOn(require('child_process'), 'exec').and.callThrough();
            const run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
                commands: [
                    {
                        command: `echo 'Hello World'`,
                    },
                ],
            });
            yield run.result;
            expect(exec).toHaveBeenCalledWith(`echo 'Hello World'`, {
                maxBuffer: file_utils_1.TEN_MEGABYTES,
                env: Object.assign(Object.assign({}, process.env), { FORCE_COLOR: `false` }),
            });
        }));
        it('should set FORCE_COLOR=false when running with --color', () => __awaiter(void 0, void 0, void 0, function* () {
            const exec = spyOn(require('child_process'), 'exec').and.callThrough();
            const run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
                commands: [
                    {
                        command: `echo 'Hello World'`,
                    },
                ],
                color: true,
            });
            yield run.result;
            expect(exec).toHaveBeenCalledWith(`echo 'Hello World'`, {
                maxBuffer: file_utils_1.TEN_MEGABYTES,
                env: Object.assign(Object.assign({}, process.env), { FORCE_COLOR: `true` }),
            });
        }));
    });
    it('should run the task in the specified working directory', () => __awaiter(void 0, void 0, void 0, function* () {
        const f = tmp_1.fileSync().name;
        let run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
            commands: [
                {
                    command: `pwd >> ${f}`,
                },
            ],
        });
        let result = yield run.result;
        expect(result).toEqual(jasmine.objectContaining({ success: true }));
        expect(readFile(f)).not.toContain('/packages');
        run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
            commands: [
                {
                    command: `pwd >> ${f}`,
                },
            ],
            cwd: 'packages',
        });
        result = yield run.result;
        expect(result).toEqual(jasmine.objectContaining({ success: true }));
        expect(readFile(f)).toContain('/packages');
    }));
    describe('dotenv', () => {
        beforeAll(() => {
            fs_1.writeFileSync('.env', 'NRWL_SITE=https://nrwl.io/');
        });
        beforeEach(() => {
            delete process.env.NRWL_SITE;
            delete process.env.NX_SITE;
        });
        afterAll(() => {
            fs_1.unlinkSync('.env');
        });
        it('should load the root .env file by default if there is one', () => __awaiter(void 0, void 0, void 0, function* () {
            let f = tmp_1.fileSync().name;
            let run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
                commands: [
                    {
                        command: `echo $NRWL_SITE >> ${f}`,
                    },
                ],
            });
            let result = yield run.result;
            expect(result).toEqual(jasmine.objectContaining({ success: true }));
            expect(readFile(f)).toEqual('https://nrwl.io/');
        }));
        it('should load the specified .env file instead of the root one', () => __awaiter(void 0, void 0, void 0, function* () {
            const devEnv = tmp_1.fileSync().name;
            fs_1.writeFileSync(devEnv, 'NX_SITE=https://nx.dev/');
            let f = tmp_1.fileSync().name;
            let run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
                commands: [
                    {
                        command: `echo $NX_SITE >> ${f} && echo $NRWL_SITE >> ${f}`,
                    },
                ],
                envFile: devEnv,
            });
            let result = yield run.result;
            expect(result).toEqual(jasmine.objectContaining({ success: true }));
            expect(readFile(f)).toEqual('https://nx.dev/');
        }));
        it('should error if the specified .env file does not exist', () => __awaiter(void 0, void 0, void 0, function* () {
            let f = tmp_1.fileSync().name;
            let run = yield architect.scheduleBuilder('@nrwl/workspace:run-commands', {
                commands: [
                    {
                        command: `echo $NX_SITE >> ${f} && echo $NRWL_SITE >> ${f}`,
                    },
                ],
                envFile: '/somePath/.fakeEnv',
            });
            yield expect(run.result).rejects.toThrow(`no such file or directory, open '/somePath/.fakeEnv'`);
        }));
    });
});
