"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const cache_1 = require("./cache");
const file_utils_1 = require("../core/file-utils");
const tasks_runner_1 = require("./tasks-runner");
const utils_1 = require("./utils");
const child_process_1 = require("child_process");
const output_1 = require("../utils/output");
const path = require("path");
const fs = require("fs");
const app_root_1 = require("../utils/app-root");
class TaskOrchestrator {
    constructor(initiatingProject, projectGraph, options) {
        this.initiatingProject = initiatingProject;
        this.projectGraph = projectGraph;
        this.options = options;
        this.workspaceRoot = app_root_1.appRootPath;
        this.cache = new cache_1.Cache(this.options);
        this.cli = file_utils_1.cliCommand();
    }
    run(tasksInStage) {
        return __awaiter(this, void 0, void 0, function* () {
            const { cached, rest } = yield this.splitTasksIntoCachedAndNotCached(tasksInStage);
            const r1 = yield this.applyCachedResults(cached);
            const r2 = yield this.runRest(rest);
            this.cache.removeOldCacheRecords();
            return [...r1, ...r2];
        });
    }
    runRest(tasks) {
        return __awaiter(this, void 0, void 0, function* () {
            const left = [...tasks];
            const res = [];
            const that = this;
            function takeFromQueue() {
                if (left.length > 0) {
                    const task = left.pop();
                    return that
                        .forkProcess(task)
                        .then((code) => {
                        res.push({
                            task,
                            success: code === 0,
                            type: tasks_runner_1.AffectedEventType.TaskComplete,
                        });
                    })
                        .then(takeFromQueue)
                        .catch(takeFromQueue);
                }
                else {
                    return Promise.resolve(null);
                }
            }
            const wait = [];
            // initial seeding
            const maxParallel = this.options.parallel
                ? this.options.maxParallel || 3
                : 1;
            for (let i = 0; i < maxParallel; ++i) {
                wait.push(takeFromQueue());
            }
            yield Promise.all(wait);
            return res;
        });
    }
    splitTasksIntoCachedAndNotCached(tasks) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.options.skipNxCache || this.options.skipNxCache === undefined) {
                return { cached: [], rest: tasks };
            }
            else {
                const cached = [];
                const rest = [];
                yield Promise.all(tasks.map((task) => __awaiter(this, void 0, void 0, function* () {
                    const cachedResult = yield this.cache.get(task);
                    if (cachedResult) {
                        cached.push({ task, cachedResult });
                    }
                    else {
                        rest.push(task);
                    }
                })));
                return { cached, rest };
            }
        });
    }
    applyCachedResults(tasks) {
        tasks.forEach((t) => {
            this.options.lifeCycle.startTask(t.task);
            if (!this.initiatingProject ||
                this.initiatingProject === t.task.target.project) {
                const args = this.getCommandArgs(t.task);
                output_1.output.logCommand(`${this.cli} ${args.join(' ')}`);
                output_1.output.note({ title: `Cached Output:` });
                process.stdout.write(t.cachedResult.terminalOutput);
            }
            const outputs = utils_1.getOutputs(this.projectGraph.nodes, t.task);
            this.cache.copyFilesFromCache(t.cachedResult, outputs);
            this.options.lifeCycle.endTask(t.task, 0);
        });
        return tasks.reduce((m, c) => {
            m.push({
                task: c.task,
                type: tasks_runner_1.AffectedEventType.TaskCacheRead,
                success: true,
            });
            return m;
        }, []);
    }
    forkProcess(task) {
        const taskOutputs = utils_1.getOutputs(this.projectGraph.nodes, task);
        const outputPath = this.cache.temporaryOutputPath(task);
        return new Promise((res, rej) => {
            try {
                this.options.lifeCycle.startTask(task);
                const forwardOutput = this.shouldForwardOutput(outputPath, task);
                const env = this.envForForkedProcess(task, outputPath, forwardOutput);
                const args = this.getCommandArgs(task);
                const commandLine = `${this.cli} ${args.join(' ')}`;
                if (forwardOutput) {
                    output_1.output.logCommand(commandLine);
                }
                const p = child_process_1.fork(this.getCommand(), args, {
                    stdio: ['inherit', 'inherit', 'inherit', 'ipc'],
                    env,
                });
                p.on('close', (code) => {
                    // we didn't print any output as we were running the command
                    // print all the collected output
                    if (!forwardOutput) {
                        output_1.output.logCommand(commandLine);
                        process.stdout.write(fs.readFileSync(outputPath));
                    }
                    if (outputPath && code === 0) {
                        this.cache.put(task, outputPath, taskOutputs).then(() => {
                            this.options.lifeCycle.endTask(task, code);
                            res(code);
                        });
                    }
                    else {
                        this.options.lifeCycle.endTask(task, code);
                        res(code);
                    }
                });
            }
            catch (e) {
                console.error(e);
                rej(e);
            }
        });
    }
    envForForkedProcess(task, outputPath, forwardOutput) {
        const env = Object.assign({}, process.env);
        if (outputPath) {
            env.NX_TERMINAL_OUTPUT_PATH = outputPath;
            if (this.options.captureStderr) {
                env.NX_TERMINAL_CAPTURE_STDERR = 'true';
            }
            // TODO: remove this once we have a reasonable way to configure it
            if (task.target.target === 'test') {
                env.NX_TERMINAL_CAPTURE_STDERR = 'true';
            }
            if (forwardOutput) {
                env.NX_FORWARD_OUTPUT = 'true';
            }
        }
        return env;
    }
    shouldForwardOutput(outputPath, task) {
        if (!outputPath)
            return true;
        if (!this.options.parallel)
            return true;
        if (task.target.project === this.initiatingProject)
            return true;
        return false;
    }
    getCommand() {
        return path.join(this.workspaceRoot, 'node_modules', '@nrwl', 'cli', 'lib', 'run-cli.js');
    }
    getCommandArgs(task) {
        const args = Object.entries(task.overrides || {}).map(([prop, value]) => `--${prop}=${value}`);
        const config = task.target.configuration
            ? `:${task.target.configuration}`
            : '';
        return [
            'run',
            `${task.target.project}:${task.target.target}${config}`,
            ...args,
        ];
    }
}
exports.TaskOrchestrator = TaskOrchestrator;
