"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const workspace_results_1 = require("./workspace-results");
const fileutils_1 = require("../utils/fileutils");
const project_graph_1 = require("..//core/project-graph");
describe('WorkspacesResults', () => {
    let results;
    beforeEach(() => {
        results = new workspace_results_1.WorkspaceResults('test', {
            proj: {
                name: 'proj',
                type: project_graph_1.ProjectType.app,
                data: {
                    files: [],
                },
            },
        });
    });
    it('should be instantiable', () => {
        expect(results).toBeTruthy();
    });
    it('should default with no failed projects', () => {
        expect(results.hasFailure).toBe(false);
    });
    describe('success', () => {
        it('should return true when getting results', () => {
            results.setResult('proj', true);
            expect(results.getResult('proj')).toBe(true);
        });
        it('should remove results from file system', () => {
            spyOn(fs, 'writeSync');
            spyOn(fs, 'unlinkSync');
            spyOn(fs, 'existsSync').and.returnValue(true);
            results.setResult('proj', true);
            results.saveResults();
            expect(fs.writeSync).not.toHaveBeenCalled();
            expect(fs.unlinkSync).toHaveBeenCalledWith('dist/.nx-results');
        });
    });
    describe('fail', () => {
        it('should return false when getting results', () => {
            results.setResult('proj', false);
            expect(results.getResult('proj')).toBe(false);
        });
        it('should save results to file system', () => {
            spyOn(fs, 'writeFileSync');
            results.setResult('proj', false);
            results.saveResults();
            expect(fs.writeFileSync).toHaveBeenCalledWith('dist/.nx-results', fileutils_1.serializeJson({
                command: 'test',
                results: {
                    proj: false,
                },
            }));
        });
    });
    describe('when results already exist', () => {
        beforeEach(() => {
            spyOn(fs, 'existsSync').and.returnValue(true);
        });
        it('should read existing results', () => {
            spyOn(fs, 'readFileSync').and.returnValue(fileutils_1.serializeJson({
                command: 'test',
                results: {
                    proj: false,
                },
            }));
            results = new workspace_results_1.WorkspaceResults('test', {
                proj: {
                    name: 'proj',
                    type: project_graph_1.ProjectType.app,
                    data: {
                        files: [],
                    },
                },
            });
            expect(fs.readFileSync).toHaveBeenCalledWith('dist/.nx-results', 'utf-8');
            expect(results.getResult('proj')).toBe(false);
        });
        it('should handle a corrupted results file', () => {
            spyOn(fs, 'readFileSync').and.returnValue('invalid json');
            const runTests = () => {
                results = new workspace_results_1.WorkspaceResults('test', {
                    proj: {
                        name: 'proj',
                        type: project_graph_1.ProjectType.app,
                        data: {
                            files: [],
                        },
                    },
                });
            };
            expect(runTests).not.toThrow();
            expect(results.startedWithFailedProjects).toBeFalsy();
        });
        it('should not read the existing results when the previous command was different', () => {
            spyOn(fs, 'readFileSync').and.returnValue(fileutils_1.serializeJson({
                command: 'test',
                results: {
                    proj: false,
                },
            }));
            results = new workspace_results_1.WorkspaceResults('build', {
                proj: {
                    name: 'proj',
                    type: project_graph_1.ProjectType.app,
                    data: {
                        files: [],
                    },
                },
            });
            expect(results.getResult('proj')).toBeUndefined();
        });
        it('should invalidate existing results when the project is not run', () => {
            spyOn(fs, 'readFileSync').and.returnValue(fileutils_1.serializeJson({
                command: 'test',
                results: {
                    proj: true,
                    proj2: false,
                },
            }));
            results = new workspace_results_1.WorkspaceResults('build', {
                proj: {
                    name: 'proj',
                    type: project_graph_1.ProjectType.app,
                    data: {
                        files: [],
                    },
                },
            });
            expect(results.hasFailure).toEqual(false);
        });
    });
});
