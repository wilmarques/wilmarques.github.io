"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const migrate_1 = require("./migrate");
describe('Migration', () => {
    describe('packageJson patch', () => {
        it('should throw an error when the target package is not available', () => __awaiter(void 0, void 0, void 0, function* () {
            const migrator = new migrate_1.Migrator({
                versions: () => '1.0',
                fetch: (p, v) => {
                    throw new Error('cannot fetch');
                },
                from: {},
                to: {},
            });
            try {
                yield migrator.updatePackageJson('mypackage', 'myversion');
                throw new Error('fail');
            }
            catch (e) {
                expect(e.message).toEqual(`cannot fetch`);
            }
        }));
        it('should return a patch to the new version', () => __awaiter(void 0, void 0, void 0, function* () {
            const migrator = new migrate_1.Migrator({
                versions: () => '1.0.0',
                fetch: (p, v) => Promise.resolve({ version: '2.0.0' }),
                from: {},
                to: {},
            });
            expect(yield migrator.updatePackageJson('mypackage', '2.0.0')).toEqual({
                migrations: [],
                packageJson: {
                    mypackage: { version: '2.0.0', alwaysAddToPackageJson: false },
                },
            });
        }));
        it('should collect the information recursively from upserts', () => __awaiter(void 0, void 0, void 0, function* () {
            const migrator = new migrate_1.Migrator({
                versions: () => '1.0.0',
                fetch: (p, v) => {
                    if (p === 'parent') {
                        return Promise.resolve({
                            version: '2.0.0',
                            packageJsonUpdates: {
                                version2: {
                                    version: '2.0.0',
                                    packages: {
                                        child: { version: '2.0.0' },
                                        newChild: {
                                            version: '3.0.0',
                                            alwaysAddToPackageJson: true,
                                        },
                                    },
                                },
                            },
                            schematics: {},
                        });
                    }
                    else if (p === 'child') {
                        return Promise.resolve({ version: '2.0.0' });
                    }
                    else if (p === 'newChild') {
                        return Promise.resolve({ version: '2.0.0' });
                    }
                    else {
                        return Promise.resolve(null);
                    }
                },
                from: {},
                to: {},
            });
            expect(yield migrator.updatePackageJson('parent', '2.0.0')).toEqual({
                migrations: [],
                packageJson: {
                    parent: { version: '2.0.0', alwaysAddToPackageJson: false },
                    child: { version: '2.0.0', alwaysAddToPackageJson: false },
                    newChild: { version: '2.0.0', alwaysAddToPackageJson: true },
                },
            });
        }));
        it('should stop recursive calls when exact version', () => __awaiter(void 0, void 0, void 0, function* () {
            const migrator = new migrate_1.Migrator({
                versions: () => '1.0.0',
                fetch: (p, v) => {
                    if (p === 'parent') {
                        return Promise.resolve({
                            version: '2.0.0',
                            packageJsonUpdates: {
                                version2: {
                                    version: '2.0.0',
                                    packages: {
                                        child: { version: '2.0.0' },
                                    },
                                },
                            },
                            schematics: {},
                        });
                    }
                    else if (p === 'child') {
                        return Promise.resolve({
                            version: '2.0.0',
                            packageJsonUpdates: {
                                version2: {
                                    version: '2.0.0',
                                    packages: {
                                        parent: { version: '2.0.0' },
                                    },
                                },
                            },
                            schematics: {},
                        });
                    }
                    else {
                        return Promise.resolve(null);
                    }
                },
                from: {},
                to: {},
            });
            expect(yield migrator.updatePackageJson('parent', '2.0.0')).toEqual({
                migrations: [],
                packageJson: {
                    parent: { version: '2.0.0', alwaysAddToPackageJson: false },
                    child: { version: '2.0.0', alwaysAddToPackageJson: false },
                },
            });
        }));
        it('should set the version of a dependency to the newest', () => __awaiter(void 0, void 0, void 0, function* () {
            const migrator = new migrate_1.Migrator({
                versions: () => '1.0.0',
                fetch: (p, v) => {
                    if (p === 'parent') {
                        return Promise.resolve({
                            version: '2.0.0',
                            packageJsonUpdates: {
                                version2: {
                                    version: '2.0.0',
                                    packages: {
                                        child1: { version: '2.0.0' },
                                        child2: { version: '2.0.0' },
                                    },
                                },
                            },
                            schematics: {},
                        });
                    }
                    else if (p === 'child1') {
                        return Promise.resolve({
                            version: '2.0.0',
                            packageJsonUpdates: {
                                version2: {
                                    version: '2.0.0',
                                    packages: {
                                        grandchild: { version: '3.0.0' },
                                    },
                                },
                            },
                            schematics: {},
                        });
                    }
                    else if (p === 'child2') {
                        return Promise.resolve({
                            version: '2.0.0',
                            packageJsonUpdates: {
                                version2: {
                                    version: '2.0.0',
                                    packages: {
                                        grandchild: { version: '4.0.0' },
                                    },
                                },
                            },
                            schematics: {},
                        });
                    }
                    else {
                        return Promise.resolve({ version: '4.0.0' });
                    }
                },
                from: {},
                to: {},
            });
            expect(yield migrator.updatePackageJson('parent', '2.0.0')).toEqual({
                migrations: [],
                packageJson: {
                    parent: { version: '2.0.0', alwaysAddToPackageJson: false },
                    child1: { version: '2.0.0', alwaysAddToPackageJson: false },
                    child2: { version: '2.0.0', alwaysAddToPackageJson: false },
                    grandchild: { version: '4.0.0', alwaysAddToPackageJson: false },
                },
            });
        }));
        it('should skip the versions <= currently installed', () => __awaiter(void 0, void 0, void 0, function* () {
            const migrator = new migrate_1.Migrator({
                versions: () => '1.0.0',
                fetch: (p, v) => {
                    if (p === 'parent') {
                        return Promise.resolve({
                            version: '2.0.0',
                            packageJsonUpdates: {
                                version2: {
                                    version: '2.0.0',
                                    packages: {
                                        child: { version: '2.0.0' },
                                    },
                                },
                            },
                            schematics: {},
                        });
                    }
                    else if (p === 'child') {
                        return Promise.resolve({
                            version: '2.0.0',
                            packageJsonUpdates: {
                                version2: {
                                    version: '1.0.0',
                                    packages: {
                                        grandchild: { version: '2.0.0' },
                                    },
                                },
                            },
                            schematics: {},
                        });
                    }
                    else {
                        return Promise.resolve({ version: '2.0.0' });
                    }
                },
                from: {},
                to: {},
            });
            expect(yield migrator.updatePackageJson('parent', '2.0.0')).toEqual({
                migrations: [],
                packageJson: {
                    parent: { version: '2.0.0', alwaysAddToPackageJson: false },
                    child: { version: '2.0.0', alwaysAddToPackageJson: false },
                },
            });
        }));
        it('should conditionally process packages if they are installed', () => __awaiter(void 0, void 0, void 0, function* () {
            const migrator = new migrate_1.Migrator({
                versions: (p) => (p !== 'not-installed' ? '1.0.0' : null),
                fetch: (p, v) => {
                    if (p === 'parent') {
                        return Promise.resolve({
                            version: '2.0.0',
                            packageJsonUpdates: {
                                version2: {
                                    version: '2.0.0',
                                    packages: {
                                        child1: { version: '2.0.0', ifPackageInstalled: 'other' },
                                        child2: {
                                            version: '2.0.0',
                                            ifPackageInstalled: 'not-installed',
                                        },
                                    },
                                },
                            },
                            schematics: {},
                        });
                    }
                    else if (p === 'child1') {
                        return Promise.resolve({ version: '2.0.0' });
                    }
                    else if (p === 'child2') {
                        throw new Error('should not be processed');
                    }
                    else {
                        return Promise.resolve(null);
                    }
                },
                from: {},
                to: {},
            });
            expect(yield migrator.updatePackageJson('parent', '2.0.0')).toEqual({
                migrations: [],
                packageJson: {
                    parent: { version: '2.0.0', alwaysAddToPackageJson: false },
                    child1: { version: '2.0.0', alwaysAddToPackageJson: false },
                },
            });
        }));
        // this is temporary. if tao gets used by other projects,
        // we will extract the special casing
        it('should special case @nrwl/workspace', () => __awaiter(void 0, void 0, void 0, function* () {
            const migrator = new migrate_1.Migrator({
                versions: () => '1.0.0',
                fetch: (p, v) => Promise.resolve({ version: '2.0.0' }),
                from: {},
                to: {},
            });
            expect(yield migrator.updatePackageJson('@nrwl/workspace', '2.0.0')).toEqual({
                migrations: [],
                packageJson: {
                    '@nrwl/workspace': {
                        version: '2.0.0',
                        alwaysAddToPackageJson: false,
                    },
                    '@nrwl/angular': { version: '2.0.0', alwaysAddToPackageJson: false },
                    '@nrwl/cypress': { version: '2.0.0', alwaysAddToPackageJson: false },
                    '@nrwl/eslint-plugin-nx': {
                        version: '2.0.0',
                        alwaysAddToPackageJson: false,
                    },
                    '@nrwl/express': { version: '2.0.0', alwaysAddToPackageJson: false },
                    '@nrwl/jest': { version: '2.0.0', alwaysAddToPackageJson: false },
                    '@nrwl/linter': { version: '2.0.0', alwaysAddToPackageJson: false },
                    '@nrwl/nest': { version: '2.0.0', alwaysAddToPackageJson: false },
                    '@nrwl/next': { version: '2.0.0', alwaysAddToPackageJson: false },
                    '@nrwl/node': { version: '2.0.0', alwaysAddToPackageJson: false },
                    '@nrwl/nx-plugin': {
                        version: '2.0.0',
                        alwaysAddToPackageJson: false,
                    },
                    '@nrwl/react': { version: '2.0.0', alwaysAddToPackageJson: false },
                    '@nrwl/storybook': {
                        version: '2.0.0',
                        alwaysAddToPackageJson: false,
                    },
                    '@nrwl/tao': { version: '2.0.0', alwaysAddToPackageJson: false },
                    '@nrwl/web': { version: '2.0.0', alwaysAddToPackageJson: false },
                },
            });
        }));
        it('should not throw when packages are missing', () => __awaiter(void 0, void 0, void 0, function* () {
            const migrator = new migrate_1.Migrator({
                versions: (p) => (p === '@nrwl/nest' ? null : '1.0.0'),
                fetch: (p, v) => Promise.resolve({
                    version: '2.0.0',
                    packageJsonUpdates: { one: { version: '2.0.0', packages: {} } },
                }),
                from: {},
                to: {},
            });
            yield migrator.updatePackageJson('@nrwl/workspace', '2.0.0');
        }));
        it('should only fetch packages that are installed', () => __awaiter(void 0, void 0, void 0, function* () {
            const migrator = new migrate_1.Migrator({
                versions: (p) => (p === '@nrwl/nest' ? null : '1.0.0'),
                fetch: (p, v) => {
                    if (p === '@nrwl/nest') {
                        throw new Error('Boom');
                    }
                    return Promise.resolve({
                        version: '2.0.0',
                        packageJsonUpdates: { one: { version: '2.0.0', packages: {} } },
                    });
                },
                from: {},
                to: {},
            });
            yield migrator.updatePackageJson('@nrwl/workspace', '2.0.0');
        }));
    });
    describe('migrations', () => {
        it('should create a list of migrations to run', () => __awaiter(void 0, void 0, void 0, function* () {
            const migrator = new migrate_1.Migrator({
                versions: (p) => {
                    if (p === 'parent')
                        return '1.0.0';
                    if (p === 'child')
                        return '1.0.0';
                    return null;
                },
                fetch: (p, v) => {
                    if (p === 'parent') {
                        return Promise.resolve({
                            version: '2.0.0',
                            packageJsonUpdates: {
                                version2: {
                                    version: '2.0.0',
                                    packages: {
                                        child: { version: '2.0.0' },
                                        newChild: {
                                            version: '3.0.0',
                                        },
                                    },
                                },
                            },
                            schematics: {
                                version2: {
                                    version: '2.0.0',
                                    factory: 'parent-factory',
                                },
                            },
                        });
                    }
                    else if (p === 'child') {
                        return Promise.resolve({
                            version: '2.0.0',
                            schematics: {
                                version2: {
                                    version: '2.0.0',
                                    factory: 'child-factory',
                                },
                            },
                        });
                    }
                    else if (p === 'newChild') {
                        return Promise.resolve({
                            version: '3.0.0',
                            schematics: {
                                version2: {
                                    version: '2.0.0',
                                    factory: 'new-child-factory',
                                },
                            },
                        });
                    }
                    else {
                        return Promise.resolve(null);
                    }
                },
                from: {},
                to: {},
            });
            expect(yield migrator.updatePackageJson('parent', '2.0.0')).toEqual({
                migrations: [
                    {
                        package: 'parent',
                        version: '2.0.0',
                        name: 'version2',
                        factory: 'parent-factory',
                    },
                    {
                        package: 'child',
                        version: '2.0.0',
                        name: 'version2',
                        factory: 'child-factory',
                    },
                ],
                packageJson: {
                    parent: { version: '2.0.0', alwaysAddToPackageJson: false },
                    child: { version: '2.0.0', alwaysAddToPackageJson: false },
                    newChild: { version: '3.0.0', alwaysAddToPackageJson: false },
                },
            });
        }));
    });
    describe('normalizeVersions', () => {
        it('should return version when it meets semver requirements', () => {
            expect(migrate_1.normalizeVersion('1.2.3')).toEqual('1.2.3');
            expect(migrate_1.normalizeVersion('1.2.3-beta.1')).toEqual('1.2.3-beta.1');
        });
        it('should handle versions missing a patch or a minor', () => {
            expect(migrate_1.normalizeVersion('1.2')).toEqual('1.2.0');
            expect(migrate_1.normalizeVersion('1')).toEqual('1.0.0');
            expect(migrate_1.normalizeVersion('1-beta.1')).toEqual('1.0.0-beta.1');
        });
        it('should handle incorrect versions', () => {
            expect(migrate_1.normalizeVersion('1-invalid-version')).toEqual('1.0.0-invalid');
            expect(migrate_1.normalizeVersion('1.invalid-version')).toEqual('1.0.0');
            expect(migrate_1.normalizeVersion('invalid-version')).toEqual('0.0.0');
        });
    });
    describe('parseMigrationsOptions', () => {
        it('should work', () => {
            const r = migrate_1.parseMigrationsOptions([
                '8.12.0',
                '--from',
                '@myscope/a@12.3,@myscope/b@1.1.1',
                '--to',
                '@myscope/c@12.3.1',
            ]);
            expect(r).toEqual({
                type: 'generateMigrations',
                targetPackage: '@nrwl/workspace',
                targetVersion: '8.12.0',
                from: {
                    '@myscope/a': '12.3.0',
                    '@myscope/b': '1.1.1',
                },
                to: {
                    '@myscope/c': '12.3.1',
                },
            });
        });
        it('should handle different variations of the target package', () => {
            expect(migrate_1.parseMigrationsOptions(['8.12'])).toMatchObject({
                targetPackage: '@nrwl/workspace',
                targetVersion: '8.12.0',
            });
            expect(migrate_1.parseMigrationsOptions(['8'])).toMatchObject({
                targetPackage: '@nrwl/workspace',
                targetVersion: '8.0.0',
            });
            expect(migrate_1.parseMigrationsOptions(['next'])).toMatchObject({
                targetPackage: '@nrwl/workspace',
                targetVersion: 'next',
            });
            expect(migrate_1.parseMigrationsOptions(['@nrwl/workspace@8.12'])).toMatchObject({
                targetPackage: '@nrwl/workspace',
                targetVersion: '8.12.0',
            });
            expect(migrate_1.parseMigrationsOptions(['mypackage@8.12'])).toMatchObject({
                targetPackage: 'mypackage',
                targetVersion: '8.12.0',
            });
            expect(migrate_1.parseMigrationsOptions(['mypackage'])).toMatchObject({
                targetPackage: 'mypackage',
                targetVersion: 'latest',
            });
            expect(migrate_1.parseMigrationsOptions(['@nrwl/workspace@latest'])).toMatchObject({
                targetPackage: '@nrwl/workspace',
                targetVersion: 'latest',
            });
        });
        it('should handle incorrect from', () => {
            expect(() => migrate_1.parseMigrationsOptions(['8.12.0', '--from', '@myscope/a@'])).toThrowError(`Incorrect 'from' section. Use --from="package@version"`);
            expect(() => migrate_1.parseMigrationsOptions(['8.12.0', '--from', '@myscope/a'])).toThrowError(`Incorrect 'from' section. Use --from="package@version"`);
            expect(() => migrate_1.parseMigrationsOptions(['8.12.0', '--from', 'myscope'])).toThrowError(`Incorrect 'from' section. Use --from="package@version"`);
        });
        it('should handle incorrect to', () => {
            expect(() => migrate_1.parseMigrationsOptions(['8.12.0', '--to', '@myscope/a@'])).toThrowError(`Incorrect 'to' section. Use --to="package@version"`);
            expect(() => migrate_1.parseMigrationsOptions(['8.12.0', '--to', '@myscope/a'])).toThrowError(`Incorrect 'to' section. Use --to="package@version"`);
            expect(() => migrate_1.parseMigrationsOptions(['8.12.0', '--to', 'myscope'])).toThrowError(`Incorrect 'to' section. Use --to="package@version"`);
        });
    });
});
